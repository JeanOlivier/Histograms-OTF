Fonction histogram_single :
	- Single thread
		- Pointor translation
			- no flooring (cond. #1)
				+ Timeit[ms] : 214
				+ (sans variable tmp) Timeit[ms] : 215
			- floor (built-in) (cond #2)
				+ Timeit[ms] : 273
			- floor (using inline) (cond #3)
				+ Timeit[ms] : 345
				+ static inline pas mieux
			- floor (using static inline but int insted of int16_t) :
				+ Timeit[ms] : 324
			- floor (manual inline)(cond #4)
				+ Timeit[ms] : 346

 

Test conditions :
x - array(normal(0,2**0, 10**8), dtype = 'float32')
%timeit H_x = hist.hist1dNbits(x,n=15,ihist=None, max=3.)

Code samples : 
#1
	//#pragma omp parallel
    {
        //manage_thread_affinity(); // For 64+ logical cores on Windows
		//#pragma omp for reduction(+:hist[:N_bin])
		uint64_t* uhist = hist + (uint64_t)((1<<(n-1))); // This always works for iseven(N_bin)=True 
		for (uint64_t i=0; i<size; i++){
			if (data[i] >= max){
				//printf("OVER MAX | %.4f | %.4f\n", data[i], max);
			}
			else if (data[i] < -max){
				//printf("UNDER MIN | %.4f | %.4f\n", data[i], -max);
			}
			else{
				//uint16_t tmp = (uint16_t)((data[i]+max)/L_bin);
				int16_t tmp = (int16_t)(((data[i])/L_bin));
				//hist[ (uint16_t)(data[i]/L_bin) >> tail ]++;
				//printf("%d\t%f\t%f\t%d\t%f\n", tmp, data[i], L_bin, N_bin, max);
				uhist[ tmp ]++;
			}
		}
    }
#2 
	int16_t tmp = (int16_t)(floor((data[i])/L_bin));
#3
	(top)
	// inline mandatory function declaration
	inline int16_t int_floor_float(float x);
	(in histogram_single)
	int16_t tmp = int_floor_float((data[i]/L_bin));
	(inline definition)
	inline int16_t int_floor_float(float x)
	{
  	int16_t i = (int16_t)x; /* truncate */
  	return i - ( i > x ); /* convert trunc to floor */
	}

#4
	(in histogram_single)
	float tmp1 = data[i]/L_bin ;
	int16_t tmp2 = (int16_t)tmp1;
	int16_t tmp3 = tmp2 - ( tmp2 > tmp1 );
	uhist[ tmp3]++;
